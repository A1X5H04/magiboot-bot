name: Process Video for Bootanimation (Single Job for Local Testing)

on:
  workflow_dispatch:
    inputs:
      video:
        description: 'FileID of a video to process'
        required: true
      other_metadata:
        description: '[JSON] Other metadata including {chatId, messageId, userId, title, creator}'
        required: false

env:
  # These secrets must be configured in your repository's settings for remote execution
  # For local 'act' testing, you can provide these in your .secrets file
  BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
  TELEGRAM_BOT_WEBHOOK_URL: ${{ secrets.TELEGRAM_BOT_WEBHOOK_URL }}
  STORAGE_PROVIDER_API_KEY: ${{ secrets.STORAGE_PROVIDER_API_KEY }}

jobs:
  # =====================================================================================
  # SINGLE JOB: Process Video from Start to Finish
  # - All phases (Setup, Processing, Packaging, Deploy) are combined into one job
  #   to avoid using artifacts, which simplifies local testing with 'act'.
  # =====================================================================================
  process-video:
    name: "Process Video (Local)"
    runs-on: ubuntu-latest
    
    steps:
      # =================== Phase 1: Setup & Download ===================
      - name: "Checkout repository"
        uses: actions/checkout@v4

      - name: "Install dependencies (jq, curl, ffmpeg)"
        run: sudo apt-get update && sudo apt-get install -y jq curl ffmpeg

      - name: "Make all scripts executable"
        run: chmod +x scripts/*.sh

      - name: "Parse and validate metadata"
        id: parse_metadata
        run: |
          METADATA_JSON='${{ inputs.other_metadata }}'
          PARSED_META=$(echo "${METADATA_JSON}" | jq -c '
            {
              "jobId": .jobId,
              "chatId": .msg_metadata.chatId,
              "messageId": .msg_metadata.messageId,
              "title": .title,
              "creator": .creator,
              "ref_message_id": .ref_message_id
            }
          ')
          MSG_METADATA=$(echo "${METADATA_JSON}" | jq -c '
            {
              "chat_id": .msg_metadata.chatId,
              "message_id": .msg_metadata.messageId
            }
          ')
          echo "json_string=${PARSED_META}" >> "$GITHUB_OUTPUT"
          echo "msg_metadata=${MSG_METADATA}" >> "$GITHUB_OUTPUT"

      - name: "Send 'Setup Started' status"
        uses: ./.github/actions/send-status
        with:
          status: "processing"
          message: "ðŸš€ Workflow initiated. Setting up environment..."
          msg_metadata: ${{ steps.parse_metadata.outputs.msg_metadata }}
          progress: 5

      - name: "Download video file"
        id: download
        shell: bash
        run: |
          set -e
          FILE_ID="${{ inputs.video }}"
          BOT_TOKEN="${{ env.BOT_TOKEN }}"
          OUTPUT_FILENAME="video.mp4"
          echo "âž¡ï¸ Fetching file metadata for FileID: $FILE_ID"
          API_RESPONSE=$(curl -s "https://api.telegram.org/bot${BOT_TOKEN}/getFile?file_id=${FILE_ID}")
          OK_STATUS=$(echo "$API_RESPONSE" | jq -r '.ok')
          if [[ "$OK_STATUS" != "true" ]]; then
            ERROR_DESC=$(echo "$API_RESPONSE" | jq -r '.description')
            echo "âŒ Telegram API Error: $ERROR_DESC" >&2
            exit 1
          fi
          FILE_PATH=$(echo "$API_RESPONSE" | jq -r '.result.file_path')
          if [[ -z "$FILE_PATH" || "$FILE_PATH" == "null" ]]; then
              echo "âŒ Error: Could not extract 'file_path' from API response." >&2
              exit 1
          fi
          echo "File path found: ${FILE_PATH}"
          echo "ðŸ“¥ Downloading video..."
          DOWNLOAD_URL="https://api.telegram.org/file/bot${BOT_TOKEN}/${FILE_PATH}"
          curl -s -L -o "$OUTPUT_FILENAME" "$DOWNLOAD_URL"
          if [[ ! -s "$OUTPUT_FILENAME" ]]; then
            echo "âŒ Error: Download failed or the resulting file is empty." >&2
            exit 1
          fi
          echo "âœ… Video downloaded successfully as ${OUTPUT_FILENAME}"

      # =================== Phase 2: Process Video ===================
      - name: "Send 'Processing Started' status"
        uses: ./.github/actions/send-status
        with:
          status: "processing"
          message: "ðŸŽ¬ Video processing has started..."
          msg_metadata: ${{ steps.parse_metadata.outputs.msg_metadata }}
          progress: 25

      - name: "Create bootanimation parts"
        id: create_boot
        run: |
          chmod +x scripts/prepare_bootanimation.sh
          # The script's output (key=value pairs) is appended to GITHUB_OUTPUT
          scripts/prepare_bootanimation.sh video.mp4 >> "$GITHUB_OUTPUT"

      - name: "Show metadata"
        run: |
          echo "Output dir: ${{ steps.create_boot.outputs.boot_output_dir }}"
          echo "Duration:   ${{ steps.create_boot.outputs.boot_video_duration }}"
          echo "FPS:        ${{ steps.create_boot.outputs.boot_video_fps }}"
          echo "Resolution: ${{ steps.create_boot.outputs.boot_video_resolution }}"
          echo "Format:     ${{ steps.create_boot.outputs.boot_video_format }}"
          echo "Boot res:   ${{ steps.create_boot.outputs.boot_bootanimation_resolution }}"
          echo "Boot fps:   ${{ steps.create_boot.outputs.boot_bootanimation_fps }}"
          echo "Module type:${{ steps.create_boot.outputs.boot_bootanimation_module_type }}"

      # =================== Phase 3: Package Module ===================
      - name: "Send 'Packaging Started' status"
        uses: ./.github/actions/send-status
        with:
          status: "processing"
          message: "ðŸ“¦ Packaging the flashable module..."
          msg_metadata: ${{ steps.parse_metadata.outputs.msg_metadata }}
          progress: 65

      - name: "Package the flashable module"
        id: package_module
        run: |
          chmod +x scripts/package_module.sh
          MODULE_NAME=$(echo '${{ steps.parse_metadata.outputs.json_string }}' | jq -r '.title')
          MODULE_CREATOR=$(echo '${{ steps.parse_metadata.outputs.json_string }}' | jq -r '.creator.name')
          
          # This script returns the final filename to stdout
          FINAL_FILENAME=$(scripts/package_module.sh \
            "${{ steps.create_boot.outputs.boot_output_dir }}" \
            ./scripts/module_template \
            --module-name "$MODULE_NAME" \
            --module-creator "$MODULE_CREATOR")
          
          echo "filename=${FINAL_FILENAME}" >> "$GITHUB_OUTPUT"

      # =================== Phase 4: Deploy & Notify ===================
      - name: "Send 'Uploading' status"
        uses: ./.github/actions/send-status
        with:
          status: "processing"
          message: "â˜ï¸ Uploading module to storage..."
          msg_metadata: ${{ steps.parse_metadata.outputs.msg_metadata }}
          progress: 85

      - name: "Upload module and get download link"
        id: upload
        run: |
          chmod +x scripts/upload_file.sh
          # This script returns the download link as its only output
          
          DOWNLOAD_LINK=$(scripts/upload_file.sh "${{ steps.package_module.outputs.filename }}")
          echo "download_link=${DOWNLOAD_LINK}" >> "$GITHUB_OUTPUT"
      
      - name: "Send 'Finalizing' status at 100%"
        uses: ./.github/actions/send-status
        with:
          status: "processing"
          message: "âœ… Upload complete. Finalizing post..."
          msg_metadata: ${{ steps.parse_metadata.outputs.msg_metadata }}
          progress: 100

      - name: "Prepare final post metadata"
        id: post_data
        shell: bash
        run: |
          set -ex

          BASE_META='${{ steps.parse_metadata.outputs.json_string }}'
          DOWNLOAD_URL='${{ steps.upload.outputs.download_link }}'

          POST_METADATA=$(jq -n -c \
            --argjson base_meta "$BASE_META" \
            --arg download_url "$DOWNLOAD_URL" \
            --arg boot_res '${{ steps.create_boot.outputs.boot_bootanimation_resolution }}' \
            --arg boot_fps '${{ steps.create_boot.outputs.boot_video_fps }}' \
            --arg boot_type '${{ steps.create_boot.outputs.boot_bootanimation_module_type }}' \
            --arg duration '${{ steps.create_boot.outputs.boot_video_duration }}' \
            --arg video_res '${{ steps.create_boot.outputs.boot_video_resolution }}' \
            '
              {
                "title": $base_meta.title,
                "creator": {
                  "user_id": $base_meta.creator.id,
                  "name": $base_meta.creator.name
                },
                "download_url": $download_url,
                "video": {
                  "file_id": "${{ inputs.video }}",
                  "ref_message_id": $base_meta.ref_message_id
                },
                "details": {
                  "resolution": {
                    "module": $boot_res,
                    "video": $video_res
                  },
                  "fps": ($boot_fps | tonumber),
                  "duration": ($duration | tonumber | round),
                  "type": $boot_type
                }
              }
            '
          )

          if [[ -z "$POST_METADATA" ]]; then
            echo "âŒ Error: jq command failed and produced no output."
            exit 1
          fi

          echo "Generated metadata: $POST_METADATA"
          echo "post_metadata=$POST_METADATA" >> "$GITHUB_OUTPUT"

      - name: "Send 'Completed' status"
        uses: ./.github/actions/send-status
        with:
          status: "completed"
          message: "âœ… Success! Your bootanimation is ready."
          msg_metadata: ${{ steps.parse_metadata.outputs.msg_metadata }}
          data: ${{ steps.post_data.outputs.post_metadata }}

      # =================== Handle Failure (if any step fails) ===================
      - name: "Send Failure Notification"
        if: failure() && !cancelled()
        uses: ./.github/actions/send-status
        with:
          status: "failed"
          message: "An error occurred during the workflow. Please report to @a1x5h04"
          msg_metadata: ${{ steps.parse_metadata.outputs.msg_metadata }}
